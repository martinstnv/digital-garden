<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Research Notes</title><link>/notes/</link><description>Recent content in Notes on Research Notes</description><generator>Hugo</generator><language>en-us</language><copyright>Martin Stoynov</copyright><lastBuildDate>Sun, 22 Feb 2026 00:00:00 +0000</lastBuildDate><atom:link href="/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Compiling Code</title><link>/notes/compiling-code/</link><pubDate>Sun, 22 Feb 2026 00:00:00 +0000</pubDate><guid>/notes/compiling-code/</guid><description>Assignments Here is an example of a variable assignment:
int main() { int x; x = 3; } &amp;hellip; and here is the exact equivalent in assembler:
pushq %rbp movq %rsp, %rbp movl $3, -4(%rbp) movl $0, %eax popq %rbp ret It&amp;rsquo;s important to not that most of the instructions are responsible for starting and ending the main function, which determines where the program starts and ends.
This is the instruction that corresponds to the assignment of the x variable:</description></item><item><title>Embedding Shellcode Code Caves</title><link>/notes/embedding-shellcode-in-code-caves/</link><pubDate>Sun, 22 Feb 2026 00:00:00 +0000</pubDate><guid>/notes/embedding-shellcode-in-code-caves/</guid><description>Theory Load malicious bytes into the “code cave” of a portable executable.
This doesn’t change the file size, because you will be replacing bytes that already exist with malicious code.
Typically, when a PE file executes, it follows the instructions from top to bottom. In contrary, when a trojan executes, it will immediately jump to the section containing the shellcode, execute the it and then return back the top of the file and run the program as usual.</description></item><item><title>Embedding Shellcode in Text, Data and Resource Sections</title><link>/notes/embedding-shellcode-in-text-data-and-resource-sections/</link><pubDate>Sun, 22 Feb 2026 00:00:00 +0000</pubDate><guid>/notes/embedding-shellcode-in-text-data-and-resource-sections/</guid><description>Text Section Write the shellcode and it’s length into variables.
#include &amp;lt;windows.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; int main (VOID) { unsigned char shellcode_payload[196] = [ /* ... */ ]; unsigned int shellcode_length = 279; // ... } Allocate the memory space.
LPVOID memory_address = VirtualAlloc(NULL, shellcode_length, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE // [in, optional] LPVOID lpAddress, // [in] SIZE_T dwSize // [in] DWORD flAllocationType // [in] DWORD flProtect ); Load the shellcode into the allocated memory.</description></item><item><title>Stack Overflow</title><link>/notes/stack-overflow/</link><pubDate>Mon, 22 Dec 2025 00:00:00 +0000</pubDate><guid>/notes/stack-overflow/</guid><description>This function resembles a Fibonacci recurrence, but lacks a base case.
void fibonacci(int a, int b) { int c; c = a + b; fibonacci(b,c); } Because of the infinite recursion, each call consumes stack space until the program crashes with a stack overflow.
High Address +-----------------------------+ | | |.............................| | b | // 1 |.............................| | a | // 0 |.............................| | Return Address | |.............................| | Frame Pointer #1 | |.</description></item><item><title>Program Memory</title><link>/notes/program-memory/</link><pubDate>Sat, 20 Dec 2025 00:00:00 +0000</pubDate><guid>/notes/program-memory/</guid><description>Operating systems use virtual memory to allow processes to work as if they have the full addressable space, even if physical RAM is smaller.
Memory Addressing: Physical and Virtual Memory The following diagram illustrates a typical program memory layout on a 32-bit system, with virtual addresses spanning from 0x00000000 to 0xFFFFFFFF.
(High Address) 0xFFFFFFFF -&amp;gt; +-----------------------------+ | Command-line arguments | | and environment variables | +-----------------------------+ | Stack | |.</description></item><item><title>Memory Addressing</title><link>/notes/memory-addressing/</link><pubDate>Sun, 30 Nov 2025 00:00:00 +0000</pubDate><guid>/notes/memory-addressing/</guid><description>How a CPU’s architecture determines the size of its memory space, how memory addresses work at the byte level, and how these addresses are represented in binary and hexadecimal formats, showing the maximum memory each architecture can handle.
A 32-bit CPU architecture means that the process memory space is represented using 32 bits. The lowest memory address in this space can be visualized in binary as 0000 0000 0000 0000 0000 0000 0000 0000.</description></item></channel></rss>