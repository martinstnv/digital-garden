<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Research Notes</title><link>/notes/</link><description>Recent content in Notes on Research Notes</description><generator>Hugo</generator><language>en-us</language><copyright>Martin Stoynov</copyright><lastBuildDate>Mon, 23 Feb 2026 00:00:00 +0000</lastBuildDate><atom:link href="/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux Kernel Primitives for Containerization</title><link>/notes/linux-kernel-primitives-for-containerization/</link><pubDate>Mon, 23 Feb 2026 00:00:00 +0000</pubDate><guid>/notes/linux-kernel-primitives-for-containerization/</guid><description>Theory Containers are standard user-space processes running on a host operating system. They&amp;rsquo;re considered &amp;ldquo;containers&amp;rdquo; because the Linux kernel applies isolation boundaries around them. Through this isolation, each process has its own view of system resources, such as processes, networking, and filesystems, creating the illusion that it&amp;rsquo;s running on its own machine. In reality, all containers share the same host kernel.
This model of containerization is primarily enabled by two kernel features: namespaces, which provide resource isolation, and cgroups, which control and limit resource usage.</description></item><item><title>Program Memory Layout</title><link>/notes/program-memory/</link><pubDate>Sat, 20 Dec 2025 00:00:00 +0000</pubDate><guid>/notes/program-memory/</guid><description>Operating systems use virtual memory to allow processes to work as if they have the full addressable space, even if physical RAM is smaller.
Memory Addressing: Physical and Virtual Memory The following diagram illustrates a typical program memory layout on a 32-bit system, with virtual addresses spanning from 0x00000000 to 0xFFFFFFFF.
(High Address) 0xFFFFFFFF -&amp;gt; +-----------------------------+ | Command-line arguments | | and environment variables | +-----------------------------+ | Stack | |.</description></item><item><title>Memory Addressing</title><link>/notes/memory-addressing/</link><pubDate>Sun, 30 Nov 2025 00:00:00 +0000</pubDate><guid>/notes/memory-addressing/</guid><description>How a CPU’s architecture determines the size of its memory space, how memory addresses work at the byte level, and how these addresses are represented in binary and hexadecimal formats, showing the maximum memory each architecture can handle.
A 32-bit CPU architecture means that the process memory space is represented using 32 bits. The lowest memory address in this space can be visualized in binary as 0000 0000 0000 0000 0000 0000 0000 0000.</description></item><item><title>Embedding Shellcode Code Caves</title><link>/notes/embedding-shellcode-in-code-caves/</link><pubDate>Sat, 10 Feb 2024 00:00:00 +0000</pubDate><guid>/notes/embedding-shellcode-in-code-caves/</guid><description>Theory Load malicious bytes into the “code cave” of a portable executable.
This doesn’t change the file size, because you will be replacing bytes that already exist with malicious code.
Typically, when a PE file executes, it follows the instructions from top to bottom. In contrary, when a trojan executes, it will immediately jump to the section containing the shellcode, execute the it and then return back the top of the file and run the program as usual.</description></item><item><title>Embedding Shellcode in Text, Data and Resource Sections</title><link>/notes/embedding-shellcode-in-text-data-and-resource-sections/</link><pubDate>Fri, 09 Feb 2024 00:00:00 +0000</pubDate><guid>/notes/embedding-shellcode-in-text-data-and-resource-sections/</guid><description>Text Section Write the shellcode and it’s length into variables.
#include &amp;lt;windows.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; int main (VOID) { unsigned char shellcode_payload[196] = [ /* ... */ ]; unsigned int shellcode_length = 279; // ... } Allocate the memory space.
LPVOID memory_address = VirtualAlloc(NULL, shellcode_length, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE // [in, optional] LPVOID lpAddress, // [in] SIZE_T dwSize // [in] DWORD flAllocationType // [in] DWORD flProtect ); Load the shellcode into the allocated memory.</description></item></channel></rss>