<!doctype html><html lang=en-us><head><title>Linux Kernel Primitives for Containerization // Research Notes</title>
<link rel="shortcut icon" href=favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.127.0"><meta name=format-detection content="telephone=no"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Martin Stoynov"><meta name=description content><link rel=stylesheet href=/css/main.min.5b1fcc8902588589c4767187402a3c29f8b8d7a6fdef6d9f8f77045bb0d14fee.css><link rel=stylesheet href=/custom.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux Kernel Primitives for Containerization"><meta name=twitter:description content="Theory Containers are standard user-space processes running on a host operating system. They’re considered “containers” because the Linux kernel applies isolation boundaries around them. Through this isolation, each process has its own view of system resources, such as processes, networking, and filesystems, creating the illusion that it’s running on its own machine. In reality, all containers share the same host kernel.
This model of containerization is primarily enabled by two kernel features: namespaces, which provide resource isolation, and cgroups, which control and limit resource usage."><meta property="og:url" content="/notes/linux-kernel-primitives-for-containerization/"><meta property="og:site_name" content="Research Notes"><meta property="og:title" content="Linux Kernel Primitives for Containerization"><meta property="og:description" content="Theory Containers are standard user-space processes running on a host operating system. They’re considered “containers” because the Linux kernel applies isolation boundaries around them. Through this isolation, each process has its own view of system resources, such as processes, networking, and filesystems, creating the illusion that it’s running on its own machine. In reality, all containers share the same host kernel.
This model of containerization is primarily enabled by two kernel features: namespaces, which provide resource isolation, and cgroups, which control and limit resource usage."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2026-02-23T00:00:00+00:00"><meta property="article:modified_time" content="2026-02-23T00:00:00+00:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Kernel"><link rel=alternate type=application/rss+xml href=/index.xml title="Research Notes"></head><body><header class=app-header><a href=/><img class=app-header-avatar src=/avatar.jpg alt="Martin Stoynov"></a><h1>Research Notes</h1><nav class=app-header-menu><a class=app-header-menu-item href=/notes/>Notes</a>
-
<a class=app-header-menu-item href=/tags/>Tags</a></nav><p>A Zettelkasten-style digital garden of evolving research notes.</p><div class=app-header-social><a href=https://github.com/martinstnv target=_blank rel="noreferrer noopener"><svg class="icon icon-github" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://linkedin.com/in/martinstnv target=_blank rel="noreferrer noopener"><svg class="icon icon-linkedin" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>linkedin</title><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg>
</a><a href=https://infosec.exchange/@martinstnv target=_blank rel="noreferrer noopener"><svg class="icon icon-brand-mastodon" viewBox="0 0 24 24" fill="currentcolor"><title>Mastodon</title><path d="M23.268 5.313c-.35-2.578-2.617-4.61-5.304-5.004C17.51.242 15.792.0 11.813.0h-.03c-3.98.0-4.835.242-5.288.309C3.882.692 1.496 2.518.917 5.127.64 6.412.61 7.837.661 9.143c.074 1.874.088 3.745.26 5.611.118 1.24.325 2.47.62 3.68.55 2.237 2.777 4.098 4.96 4.857 2.336.792 4.849.923 7.256.38.265-.061.527-.132.786-.213.585-.184 1.27-.39 1.774-.753a.057.057.0 00.023-.043v-1.809a.052.052.0 00-.02-.041.053.053.0 00-.046-.01 20.282 20.282.0 01-4.709.545c-2.73.0-3.463-1.284-3.674-1.818a5.593 5.593.0 01-.319-1.433.053.053.0 01.066-.054c1.517.363 3.072.546 4.632.546.376.0.75.0 1.125-.01 1.57-.044 3.224-.124 4.768-.422.038-.008.077-.015.11-.024 2.435-.464 4.753-1.92 4.989-5.604.008-.145.03-1.52.03-1.67.002-.512.167-3.63-.024-5.545zm-3.748 9.195h-2.561V8.29c0-1.309-.55-1.976-1.67-1.976-1.23.0-1.846.79-1.846 2.35v3.403h-2.546V8.663c0-1.56-.617-2.35-1.848-2.35-1.112.0-1.668.668-1.67 1.977v6.218H4.822V8.102c0-1.31.337-2.35 1.011-3.12.696-.77 1.608-1.164 2.74-1.164 1.311.0 2.302.5 2.962 1.498l.638 1.06.638-1.06c.66-.999 1.65-1.498 2.96-1.498 1.13.0 2.043.395 2.74 1.164.675.77 1.012 1.81 1.012 3.12z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Linux Kernel Primitives for Containerization</h1><div class=post-meta><div><svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
Feb 23, 2026</div><div><svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
4 min read</div><div><svg class="icon icon-tag" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>
<a class=tag href=/tags/linux/>Linux</a>
<a class=tag href=/tags/kernel/>Kernel</a></div></div></header><div class=post-content><h1 id=theory>Theory</h1><p>Containers are standard user-space processes running on a host operating system. They&rsquo;re considered &ldquo;containers&rdquo; because the Linux kernel applies isolation boundaries around them. Through this isolation, each process has its own view of system resources, such as processes, networking, and filesystems, creating the illusion that it&rsquo;s running on its own machine. In reality, all containers share the same host kernel.</p><p>This model of containerization is primarily enabled by two kernel features: namespaces, which provide resource isolation, and cgroups, which control and limit resource usage. Namespaces define what a process can see. They isolate views of system resources such as process IDs, network interfaces, mount points, and hostnames. Cgroups, on the other hand, define how much of those resources a process can use. They enforce limits and accounting for CPU, memory, disk I/O, and other system resources.</p><h2 id=process-namespaces>Process Namespaces</h2><p>On a typical Linux system, all processes share a single global PID space. A PID namespace changes that by giving a container its own isolated process tree. Inside the container, the main process appears as PID 1, just like the init process on a freshly booted system. From the host&rsquo;s perspective, however, that same process has its actual PID (often a high number) within the global namespace.</p><h2 id=mount-namespaces>Mount Namespaces</h2><p>Mount namespaces isolate the filesystem view. Although containers share the same underlying kernel, they can see entirely different filesystem hierarchies. The container&rsquo;s root filesystem is constructed from image layers, which are mounted into the container&rsquo;s mount namespace. As a result, the container has its own view of what is mounted and where, independent of the host.</p><h2 id=network-namespaces>Network Namespaces</h2><p>Network namespaces provide containers with their own network stack, including interfaces, routing tables, and port space. This isolation allows multiple containers to bind to the same port number without conflict, since each operates within its own separate network namespace.</p><h2 id=user-namespaces>User Namespaces</h2><p>User namespaces allow user and group IDs inside a container to be mapped to different IDs on the host. For example, a process running as root (UID 0) inside the container can be mapped to an unprivileged user ID outside the container, reducing the security risk to the host system.</p><h2 id=control-groups-cgroups>Control Groups (cgroups)</h2><p>Control groups, or cgroups, manage and limit resource usage. They enforce constraints on CPU, memory, disk I/O, and other resources, ensuring that one container cannot monopolize system resources and starve other workloads on the same host.</p><h2 id=non-linux-containerization>Non-Linux Containerization</h2><p>Containers are a linux kernel feature. MacOS runs the Darwin kernel and Windows runs NT, neither of which has the features containers need, so softwares like Docker create a lightweight Linux VM in the background. Containers run inside that VM, not directly on the host machine, which is why it feels slower. Files are being synced across the VM boundary (3 times slower than native Linux). Network traffic also routes through the VM</p><h1 id=practice>Practice</h1><p>The following command creates a new PID namespace and starts a shell inside it.</p><pre tabindex=0><code>user@host:~$ sudo unshare --pid --fork --mount-proc sh
</code></pre><p>Inside the new namespace, the shell sees itself as PID 1, with its own isolated process tree.</p><pre tabindex=0><code># ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.0   2380  1408 pts/1    S    21:39   0:00 sh
root           2  0.0  0.0  10716  4096 pts/1    R+   21:39   0:00 ps aux
</code></pre><p>From the host&rsquo;s global PID namespace, the same processes appear with their real PIDs.</p><pre tabindex=0><code>user@host:~$ ps aux | grep &#34; sh&#34;
root       13285  0.0  0.0  18256  6272 pts/0    S+   21:39   0:00 sudo unshare --pid --fork --mount-proc sh
root       13286  0.0  0.0  18256  2356 pts/1    Ss   21:39   0:00 sudo unshare --pid --fork --mount-proc sh
root       13287  0.0  0.0   5268  1536 pts/1    S    21:39   0:00 unshare --pid --fork --mount-proc sh
root       13288  0.0  0.0   2380  1408 pts/1    S+   21:39   0:00 sh
paralle+   18546  0.0  0.0   6140  2048 pts/2    S+   21:45   0:00 grep --color=auto  sh
</code></pre><p>Each process has a set of namespace references exposed through the /proc filesystem. These entries are the actual namespace handles that the kernel has attached to that specific process.</p><pre tabindex=0><code>user@host:~$ sudo ls -la /proc/13288/ns/
total 0
dr-x--x--x 2 root root 0 Feb 23 21:42 .
dr-xr-xr-x 9 root root 0 Feb 23 21:39 ..
lrwxrwxrwx 1 root root 0 Feb 23 21:42 cgroup -&gt; &#39;cgroup:[4026531835]&#39;
lrwxrwxrwx 1 root root 0 Feb 23 21:42 ipc -&gt; &#39;ipc:[4026531839]&#39;
lrwxrwxrwx 1 root root 0 Feb 23 21:42 mnt -&gt; &#39;mnt:[4026532448]&#39;
lrwxrwxrwx 1 root root 0 Feb 23 21:42 net -&gt; &#39;net:[4026531840]&#39;
lrwxrwxrwx 1 root root 0 Feb 23 21:42 pid -&gt; &#39;pid:[4026532451]&#39;
lrwxrwxrwx 1 root root 0 Feb 23 21:42 pid_for_children -&gt; &#39;pid:[4026532451]&#39;
lrwxrwxrwx 1 root root 0 Feb 23 21:42 time -&gt; &#39;time:[4026531834]&#39;
lrwxrwxrwx 1 root root 0 Feb 23 21:42 time_for_children -&gt; &#39;time:[4026531834]&#39;
lrwxrwxrwx 1 root root 0 Feb 23 21:42 user -&gt; &#39;user:[4026531837]&#39;
lrwxrwxrwx 1 root root 0 Feb 23 21:42 uts -&gt; &#39;uts:[4026531838]&#39;
</code></pre><p>This is conceptually similar to how Docker’s exec command uses the setns() system call to place a new process into the existing namespaces of a running container.</p></div><div class=post-footer></div></article></main></body></html>