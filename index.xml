<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Digital Garden</title><link>/</link><description>Recent content on Digital Garden</description><generator>Hugo</generator><language>en-us</language><copyright>Martin Stoynov</copyright><lastBuildDate>Tue, 23 Dec 2025 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Buffer Overflow</title><link>/posts/buffer-overflow/</link><pubDate>Tue, 23 Dec 2025 00:00:00 +0000</pubDate><guid>/posts/buffer-overflow/</guid><description>High Address +-----------------------------+ | | |.............................| | a | // 0 |.............................| | b | // 1 |.............................| | Return Address | |.............................| | Frame Pointer #1 | |.............................| | c | // 1 |.............................| | a | // 1 |.............................| | b | // 2 |.............................| | Return Address | |.............................| | Frame Pointer (#3) | |.............................| &amp;lt;- Frame Pointer #3 | c | // 3 |.............................| Low Address</description></item><item><title>Stack Overflow</title><link>/posts/stack-overflow/</link><pubDate>Mon, 22 Dec 2025 00:00:00 +0000</pubDate><guid>/posts/stack-overflow/</guid><description>This function resembles a Fibonacci recurrence, but lacks a base case.
void fibonacci(int a, int b) { int c; c = a + b; fibonacci(b,c); } Because of the infinite recursion, each call consumes stack space until the program crashes with a stack overflow.
High Address +-----------------------------+ | | |.............................| | b | // 1 |.............................| | a | // 0 |.............................| | Return Address | |.............................| | Frame Pointer #1 | |.</description></item><item><title>Portable Executables</title><link>/posts/portable-executable/</link><pubDate>Sun, 21 Dec 2025 00:00:00 +0000</pubDate><guid>/posts/portable-executable/</guid><description>Portable executables are composed of two main areas - a header and sections. The header provides general information about the portable executables.
|------------|------------|--------------------| | | | DOS Header | | | | PE Header | | | Header | Optional Header | | | | Data Directories | | | | Sections Table | | main.exe |------------|--------------------| | | | Code | | | Sections | Imports | | | | Data | |------------|------------|--------------------| https://www.</description></item><item><title>Program Memory</title><link>/posts/program-memory/</link><pubDate>Sat, 20 Dec 2025 00:00:00 +0000</pubDate><guid>/posts/program-memory/</guid><description>Operating systems use virtual memory to allow processes to work as if they have the full addressable space, even if physical RAM is smaller.
Memory Addressing: Physical and Virtual Memory The following diagram illustrates a typical program memory layout on a 32-bit system, with virtual addresses spanning from 0x00000000 to 0xFFFFFFFF.
(High Address) 0xFFFFFFFF -&amp;gt; +-----------------------------+ | Command-line arguments | | and environment variables | +-----------------------------+ | Stack | |.</description></item><item><title>Memory Addressing</title><link>/posts/memory-addressing/</link><pubDate>Sun, 30 Nov 2025 00:00:00 +0000</pubDate><guid>/posts/memory-addressing/</guid><description>How a CPU’s architecture determines the size of its memory space, how memory addresses work at the byte level, and how these addresses are represented in binary and hexadecimal formats, showing the maximum memory each architecture can handle.
A 32-bit CPU architecture means that the process memory space is represented using 32 bits. The lowest memory address in this space can be visualized in binary as 0000 0000 0000 0000 0000 0000 0000 0000.</description></item><item><title/><link>/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/about/</guid><description>Martin Stoynov I’m a security engineer and chapter lead with a strong passion for all aspects of cybersecurity, particularly low-level programming, exploit and malware development, reverse engineering, web security and cloud security.
My philosophy is that true expertise comes from mastering fundamentals, practicing relentlessly, and viewing every challenge as an opportunity to learn. I believe in breaking complex concepts into simple, meaningful insights, reinforcing them through consistent practice, and transforming failed attempts into iterative, structured progress.</description></item><item><title/><link>/posts/compiling-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/compiling-code/</guid><description>TODO: https://www.youtube.com/watch?v=fpnE6UAfbtU TODO: https://www.youtube.com/watch?v=RnBOOF502p0 TODO: https://www.youtube.com/watch?v=1I5ZMmrOfnA TODO: TUV Lectures TODO: GODBOLT TODO: RE4B BOOK
Assignments Here is an example of a variable assignment:
int main() { int x; x = 3; } &amp;hellip; and here is the exact equivalent in assembler:
pushq %rbp movq %rsp, %rbp movl $3, -4(%rbp) movl $0, %eax popq %rbp ret It&amp;rsquo;s important to not that most of the instructions are responsible for starting and ending the main function, which determines where the program starts and ends.</description></item></channel></rss>