<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Research Notes</title><link>/</link><description>Recent content on Research Notes</description><generator>Hugo</generator><language>en-us</language><copyright>Martin Stoynov</copyright><lastBuildDate>Mon, 22 Dec 2025 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Stack Overflow</title><link>/notes/stack-overflow/</link><pubDate>Mon, 22 Dec 2025 00:00:00 +0000</pubDate><guid>/notes/stack-overflow/</guid><description>This function resembles a Fibonacci recurrence, but lacks a base case.
void fibonacci(int a, int b) { int c; c = a + b; fibonacci(b,c); } Because of the infinite recursion, each call consumes stack space until the program crashes with a stack overflow.
High Address +-----------------------------+ | | |.............................| | b | // 1 |.............................| | a | // 0 |.............................| | Return Address | |.............................| | Frame Pointer #1 | |.</description></item><item><title>Program Memory</title><link>/notes/program-memory/</link><pubDate>Sat, 20 Dec 2025 00:00:00 +0000</pubDate><guid>/notes/program-memory/</guid><description>Operating systems use virtual memory to allow processes to work as if they have the full addressable space, even if physical RAM is smaller.
Memory Addressing: Physical and Virtual Memory The following diagram illustrates a typical program memory layout on a 32-bit system, with virtual addresses spanning from 0x00000000 to 0xFFFFFFFF.
(High Address) 0xFFFFFFFF -&amp;gt; +-----------------------------+ | Command-line arguments | | and environment variables | +-----------------------------+ | Stack | |.</description></item><item><title>Memory Addressing</title><link>/notes/memory-addressing/</link><pubDate>Sun, 30 Nov 2025 00:00:00 +0000</pubDate><guid>/notes/memory-addressing/</guid><description>How a CPUâ€™s architecture determines the size of its memory space, how memory addresses work at the byte level, and how these addresses are represented in binary and hexadecimal formats, showing the maximum memory each architecture can handle.
A 32-bit CPU architecture means that the process memory space is represented using 32 bits. The lowest memory address in this space can be visualized in binary as 0000 0000 0000 0000 0000 0000 0000 0000.</description></item><item><title/><link>/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/about/</guid><description>Martin Stoynov My philosophy is that true expertise comes from mastering fundamentals, practicing relentlessly, and viewing every challenge as an opportunity to learn. I believe in breaking complex concepts into simple, meaningful insights, reinforcing them through consistent practice, and transforming failed attempts into iterative, structured progress.</description></item><item><title>Compiling Code</title><link>/notes/compiling-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/compiling-code/</guid><description>Assignments Here is an example of a variable assignment:
int main() { int x; x = 3; } &amp;hellip; and here is the exact equivalent in assembler:
pushq %rbp movq %rsp, %rbp movl $3, -4(%rbp) movl $0, %eax popq %rbp ret It&amp;rsquo;s important to not that most of the instructions are responsible for starting and ending the main function, which determines where the program starts and ends.
This is the instruction that corresponds to the assignment of the x variable:</description></item></channel></rss>